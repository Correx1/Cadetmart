import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/app/lib/supabase';

export async function POST(request: NextRequest) {
  // Verify webhook authenticity
  const verifHash = request.headers.get('verif-hash');
  const secretHash = process.env.FLUTTERWAVE_SECRET_HASH;

  if (verifHash !== secretHash) {
    console.error('❌ Invalid webhook hash');
    return NextResponse.json({ error: 'Invalid hash' }, { status: 403 });
  }

  try {
    const body = await request.json();
    const data = body.data;

    // Validate data exists and has required fields
    if (!data) {
      console.warn('⚠️ Webhook data not in expected format, skipping');
      return NextResponse.json({ message: 'Webhook format not supported' }, { status: 200 });
    }

    // Check for required fields (handle both camelCase and snake_case)
    const txRef = data.txRef || data.tx_ref;
    const status = data.status;
    const customer = data.customer;
    const meta = data.meta || body.meta_data; // meta_data is at root level in some webhooks

    if (!status || !txRef || !customer) {
      console.error('❌ Missing required fields in webhook data');
      return NextResponse.json({ message: 'Missing required fields' }, { status: 200 });
    }

    // Check if payment was successful
    const validStatuses = ['successful', 'completed'];
    const isSuccessful = validStatuses.some(
      s => status.toLowerCase() === s
    );

    if (!isSuccessful) {
      console.warn(`⚠️ Skipping webhook for non-successful status: ${status}`);
      return NextResponse.json({ message: 'Payment not completed' }, { status: 200 });
    }

    // Clean up email address (remove Flutterwave test prefix)
    let cleanEmail = customer.email;
    if (cleanEmail.includes('_')) {
      // Extract actual email from format: ravesb_xxxxx_actual@email.com
      const parts = cleanEmail.split('_');
      if (parts.length >= 3) {
        cleanEmail = parts.slice(2).join('_'); // Get everything after second underscore
      }
    }
    // Get customer name from meta if customer.name is "Cadetmart"
    const customerName = (customer.name === 'Cadetmart' || !customer.name) 
      ? (meta?.name || customer.name)
      : customer.name;
    
    // Prepare order data for Supabase - matches new schema
    const orderData = {
      order_number: txRef,
      person_name: customerName, // Use corrected customer name
      email: cleanEmail,
      phone: customer.phone_number || meta?.phone || '',
      location: meta?.location || '',
      items: meta?.items || '',
      total_price: data.amount,
      transaction_id: data.id,
      payment_status: status,
      order_status: 'Confirmed', // Default status
      // created_at is auto-generated by Supabase
      // id is auto-generated by Supabase
    };

    // Prepare email data - camelCase for email functions
    const emailData = {
      orderNumber: txRef,
      personName: customerName, // Use corrected customer name
      email: cleanEmail,
      phone: customer.phone_number || meta?.phone || '',
      location: meta?.location || '',
      items: meta?.items || '',
      totalPrice: data.amount,
      transactionId: data.id,
      paymentStatus: status,
    };

    // Save to Supabase
    const { error } = await supabase
      .from('orders')
      .insert([orderData]);

    if (error) {
      console.error('❌ Supabase insert error:', error);
      throw new Error('Failed to save order to database');
    }

    // Send to Google Sheets for email notifications
    let googleSheetsSent = false;
    try {
      const googleSheetsUrl = process.env.GOOGLE_SHEETS_WEBHOOK_URL;
      
      if (googleSheetsUrl) {
        const googleSheetsResponse = await fetch(googleSheetsUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(emailData),
        });

        const googleSheetsResult = await googleSheetsResponse.json();
        googleSheetsSent = googleSheetsResult.status === 'success';
        
        if (googleSheetsResult.customerEmailSent) {
          }
        if (googleSheetsResult.adminEmailSent) {
          }
      } else {
        console.warn('⚠️ GOOGLE_SHEETS_WEBHOOK_URL not configured');
      }
    } catch (googleSheetsError) {
      console.error('❌ Google Sheets error:', googleSheetsError);
      // Don't fail the webhook if Google Sheets fails
    }

    // Update inventory in Sanity
    let inventoryUpdated = false;
    try {
      if (meta?.items) {
        const inventoryResponse = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/inventory/update-sales`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ items: meta.items }),
        });

        if (inventoryResponse.ok) {
          const inventoryResult = await inventoryResponse.json();
          inventoryUpdated = true;
        } else {
          console.error('❌ Inventory update failed:', await inventoryResponse.text());
        }
      }
    } catch (inventoryError) {
      console.error('❌ Inventory update error:', inventoryError);
      // Don't fail the webhook if inventory update fails
    }

    return NextResponse.json({ 
      message: 'Order processed and saved',
      supabaseSaved: true,
      googleSheetsSent,
      inventoryUpdated
    });

  } catch (error) {
    console.error('Webhook error:', error);
    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });
  }
}
