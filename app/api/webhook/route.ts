import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/app/lib/supabase';

export async function POST(request: NextRequest) {
  // Verify webhook authenticity
  const verifHash = request.headers.get('verif-hash');
  const secretHash = process.env.FLUTTERWAVE_SECRET_HASH;

  if (verifHash !== secretHash) {
    console.error('‚ùå Invalid webhook hash');
    return NextResponse.json({ error: 'Invalid hash' }, { status: 403 });
  }

  try {
    const body = await request.json();
    const data = body.data;

    // Validate data exists and has required fields
    if (!data) {
      console.warn('‚ö†Ô∏è Webhook data not in expected format, skipping');
      return NextResponse.json({ message: 'Webhook format not supported' }, { status: 200 });
    }

    // Check for required fields (handle both camelCase and snake_case)
    const txRef = data.txRef || data.tx_ref;
    const status = data.status;
    const customer = data.customer;
    const meta = data.meta || body.meta_data; // meta_data is at root level in some webhooks

    if (!status || !txRef || !customer) {
      console.error('‚ùå Missing required fields in webhook data');
      return NextResponse.json({ message: 'Missing required fields' }, { status: 200 });
    }

    // Check if payment was successful
    const validStatuses = ['successful', 'completed'];
    const isSuccessful = validStatuses.some(
      s => status.toLowerCase() === s
    );

    if (!isSuccessful) {
      console.warn(`‚ö†Ô∏è Skipping webhook for non-successful status: ${status}`);
      return NextResponse.json({ message: 'Payment not completed' }, { status: 200 });
    }

    // üîç DEBUG: Log all email-related data from Flutterwave
    console.log('üîç WEBHOOK DEBUG - Email Tracing:');
    console.log('üìß customer.email:', customer.email);
    console.log('üìß customer.name:', customer.name);
    console.log('üìß customer.phone_number:', customer.phone_number);
    console.log('üìß meta?.email:', meta?.email);
    console.log('üìß meta?.name:', meta?.name);
    console.log('üìß meta?.phone:', meta?.phone);
    console.log('üì¶ Full customer object:', JSON.stringify(customer, null, 2));
    console.log('üì¶ Full meta object:', JSON.stringify(meta, null, 2));

    // Get customer email directly (no test mode cleaning needed in production)
    const customerEmail = customer.email;
    
    // Get customer name from meta if customer.name is "Cadetmart"
    const customerName = (customer.name === 'Cadetmart' || !customer.name) 
      ? (meta?.name || customer.name)
      : customer.name;
    
    // Prepare order data for Supabase - matches new schema
    const orderData = {
      order_number: txRef,
      person_name: customerName, // Use corrected customer name
      email: customerEmail,
      phone: customer.phone_number || meta?.phone || '',
      location: meta?.location || '',
      items: meta?.items || '',
      total_price: data.amount,
      transaction_id: data.id,
      payment_status: status,
      order_status: 'Confirmed', // Default status
      // created_at is auto-generated by Supabase
      // id is auto-generated by Supabase
    };

    // Prepare email data - camelCase for email functions
    const emailData = {
      orderNumber: txRef,
      personName: customerName, // Use corrected customer name
      email: customerEmail,
      phone: customer.phone_number || meta?.phone || '',
      location: meta?.location || '',
      items: meta?.items || '',
      totalPrice: data.amount,
      transactionId: data.id,
      paymentStatus: status,
    };

    // Save to Supabase
    const { error } = await supabase
      .from('orders')
      .insert([orderData]);

    if (error) {
      console.error('‚ùå Supabase insert error:', error);
      throw new Error('Failed to save order to database');
    }

    // Send to Google Sheets for email notifications
    let googleSheetsSent = false;
    try {
      const googleSheetsUrl = process.env.GOOGLE_SHEETS_WEBHOOK_URL;
      
      if (googleSheetsUrl) {
        const googleSheetsResponse = await fetch(googleSheetsUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(emailData),
        });

        const googleSheetsResult = await googleSheetsResponse.json();
        googleSheetsSent = googleSheetsResult.status === 'success';
        
        if (googleSheetsResult.customerEmailSent) {
          }
        if (googleSheetsResult.adminEmailSent) {
          }
      } else {
        console.warn('‚ö†Ô∏è GOOGLE_SHEETS_WEBHOOK_URL not configured');
      }
    } catch (googleSheetsError) {
      console.error('‚ùå Google Sheets error:', googleSheetsError);
      // Don't fail the webhook if Google Sheets fails
    }

    // Update inventory in Sanity
    let inventoryUpdated = false;
    try {
      if (meta?.items) {
        // Parse items if it's a JSON string
        const itemsArray = typeof meta.items === 'string' ? JSON.parse(meta.items) : meta.items;
        
        const inventoryResponse = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/inventory/update-sales`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ items: itemsArray }),
        });

        if (inventoryResponse.ok) {
          const inventoryResult = await inventoryResponse.json();
          inventoryUpdated = true;
          console.log('‚úÖ Inventory updated:', inventoryResult);
        } else {
          console.error('‚ùå Inventory update failed:', await inventoryResponse.text());
        }
      }
    } catch (inventoryError) {
      console.error('‚ùå Inventory update error:', inventoryError);
      // Don't fail the webhook if inventory update fails
    }

    return NextResponse.json({ 
      message: 'Order processed and saved',
      supabaseSaved: true,
      googleSheetsSent,
      inventoryUpdated
    });

  } catch (error) {
    console.error('Webhook error:', error);
    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });
  }
}
